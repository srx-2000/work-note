# 概念

## 初印象

​	首先最开始的一个概念就是在unity引擎中，是以组件为单位进行脚本编写的，如果用javaweb中的一个概念来说的话【面向接口编程】，就是**面向组件编程**，在unity中有两个基础概念，一个是物体对象，即一个场景中的物体。而另一个则是组件，所谓的游戏的编写，其实可以粗糙的理解为在一个个的场景中，创建一个个物体对象，并在这些物体对象上搭载上各种的组件，使其拥有各种各样的效果。如：当一个矩形物体搭载上一个重力组件时就会具有重力组件的效果【这里的重力组件是unity内置的一个脚本】，同样的我们在编写游戏的时候也可以自己编写一系列的脚本，并将这些脚本挂载到各个物体上。

​	还有一个比较重要的理解就是，unity内置了很多组件，这些组件花里胡哨的一大堆，看着都特别复杂，但其本质也都是一个个用代码编写的脚本而已，只不过暴露出了很多参数可以供使用者修改。

# 基础

## 脚本的生命周期

![image-20230513180023385](脚本概念及基础.assets/image-20230513180023385.png)

> **注意：**	

> 1. 其中Awake方法是一个脚本只要挂载在一个对象上之后，只要这个对象第一次出现就会调用，不论是否启用，但同时也只会调用一次。
> 2. 而OnEable方法则是在脚本挂载到一个对象之上后，点击启用后就会调用一次，如果我多次在启用和关闭之前横跳，那么这个方法同样也会被反复调用，但同样的如果没有上述的反复横跳的话，这个方法同样也只会被调用一次。
> 3. onDisable这个方法主要是与OnEnable进行对应的，OnEnable是启用组件时调用，OnDisable则是关闭组件时调用
> 4. OnDestroy这个方法一定要注意是在组件被销毁时调用的，而非对象被销毁时调用的，这也就说明后续肯定有API是可以只销毁某个对象上的某个组件而不销毁对象的。

## 脚本编写

​	由于每种结构体和类后面相关的方法和属性太多了，所以后面在写的时候，仅将类或结构体的大类列出，并给出这个大类的作用，具体细节可以在后续代码编写时，按需通过这个大类的名称在API文档中查询。

### 结构体

​	所谓结构体本质上有些类似于java中的抽象类，但其中的所有方法皆是抽象方法，其中定义了一些基础属性【但这些基础属性并不能赋予初值】，以及这个结构体可以调用的方法之类的，以下面的Vector的Vector2举例，其中定义了x和y用以标识对象的向量及坐标。而后便是：构造器【结构体必须在构造器中给所有属性赋值，类的构造器则不需要】，right，left，down，up，one，zero等一系列上下左右移动的方法。

#### Vector

​	其中包含各种Vector，主要区分在于每种Vector中的变量数量不同，举个例子：Vector3中就包含了三个基础变量：x，y，z分别代表三个轴，主要应用于3D。以此类推可以得出Vector2是应用于2D的向量。其可以代表的东西有：坐标，向量，旋转【欧拉角，根据传入的角度旋转】，缩放【根据传入的比例进行缩放】

##### Vector2

![image-20230513212700606](脚本概念及基础.assets/image-20230513212700606.png)

##### Vector2Int

​	相较于上面的Vector2，主要区别在于Vector2中对xy的向量坐标是可以使用浮点数的，而Vector2中则是只能使用Int类型来表示xy的向量坐标。

##### Vector3

![image-20230513211742377](脚本概念及基础.assets/image-20230513211742377.png)

##### Vector3Int

​	相较于上面的Vector3，主要区别在于Vector3中对xyz的向量坐标是可以使用浮点数的，而Vector3Int中则是只能使用Int类型来表示xyz的向量坐标。

##### Vector4

​	目前知道的应用好像主要用于存储四元数，四元数就是一种旋转角度的表示方式，在unity中可以与欧拉角【就是0-360度的那种角】相互转换，其相对于欧拉角的优点在于性能更好，但缺点在于可读性更差。

#### Scene

​	场景，一个游戏是由多个游戏场景组成的，而每个场景中又可以包含多个对象，而每个对象又可以包含多个脚本【或者说组件】，所以场景可以粗略的理解成除了游戏本身外，在游戏开发中最大的概念了。需要注意的是场景是可以多个组合着用的，也就说有可能一个场景中会包含或组合另一个场景以达到某种效果，具体应用还得等实战。而在游戏的过程中肯定是要有多个场景之间的切换的，而这个切换的工作主要就交给了[SceneManager](#SceneManager)去完成。

### 类

​	在C#中同样也定义了类这个概念，其概念与java中的类完全相同，但这也导致其与结构体很难相互分清楚，这里罗列几个二者的区别：

1. 结构体是值类型，类是引用类型，所以结构体相较于类更轻量，执行效率更高，成本更低。
2. 结构体是存储在栈结构中的，类是存储在堆结构中的，而堆的空间更大，访问速度也更慢。
3. 类是可以继承的，结构体是无法继承的
4. 类在定义其中属性时可以对其中定义的属性直接赋值，而结构体则不行。
5. 类可以有空构造器，而结构体则必须在构造器中将之前声明的所有属性进行赋值。
6. 结构体可以不使用new关键字声明出新的对象，但相应新声明出的对象中的属性是没有初始值的【当然可以声明之后再赋值】。

#### Application

​	Application对象可以想象成为你写的这个游戏本身，其中存放了一些有关游戏的属性，如：persistentDataPath【持久化路径】、dataPath【游戏数据路径（只读）】，runlnBackground【游戏是否在后台运行】等等。具体还有很多，直接在unity中文API文档查询Application即可。

#### Input

​	在unity中Input的作用和python中的input类似，都是用于接收用户输入的，不论是键盘【key】输入还是鼠标【mouse】输入，甚至是为了适配手机端的触摸【touch】输入。一般获取用户的输入都是放到update方法里，因为update方法是每帧刷新，而游戏对象需要每帧都能实时获取用户输入才是正道。

#### GameObject

​	即游戏物体，一般可以通过gameObject方法直接获取到一个GameObject对象，所以很多情况下创建GameObject对象都是通过gameObject匿名调用的。但需要注意的是，GameObject才是真正的类，而gameObject只是一个方法用于返回一个GameObject类型的变量。当然我们也可以使用游戏物体的：名称，tag，图层获取我们想要的特定的游戏物体。有了游戏物体之后我们自然就可以获取其上的：Transform【当然这个也属于组件的一种，只不过过于特殊，单拎出来而已】，component。也可以向这个游戏物体上添加一些component等等。

​	**这里说一个特别重要的点：gameObject这个东西基本就等于java中的this，python中的self。在脚本中使用gameObject这个对象，也就意味着，我调用了挂载我这个脚本的这个对象**。

##### GameObject和gameObject之间的区别

​	在编写脚本时有的函数在GameObject和gameObject中都是有的，所以这里区分一下他们俩。

​	GameObject是一个类，如果一个方法可以通过GameObject调用，那么这个方法肯定是一个静态方法。而非静态方法是无法直接使用GameObject调用的，需要先实例化为一个实例再调用【如：AddComponent方法就只能用实例去调用】。

​	gameObject如果是放到一个脚本中直接使用的情况下，那么这个gameObject指代的就是挂载了该脚本的那个游戏对象。既然是一个游戏对象，那gameObject自然本身就已经是一个实例了。或者换一种说法，如果一个脚本中出现了直接使用gameObject对象的情况，那么证明这个脚本后面是一定会挂载到一个对象上的【不论是使用脚本动态挂载的，还是直接拖拽静态挂载的】。

#### Transform

​	即游戏物体的位置，但值得说明的是：其不仅掌控了游戏物体的位置，还掌握了游戏物体的旋转角度，大小缩放，父子组件关系【可以通过transform对象拿到，添加，删除父子组件】

##### Transform和transform之间的区别

​	与GameObject和gameObject之间的区别一样。

#### SceneManager

​	场景管理器，用于管理场景，场景的概念可以看[这里](#Scene)，其实说是管理，最主要的还是场景的切换，而场景的切换主要有两种方法，一种常规切换：即场景的切换与加载在主线程中进行，遇到大的场景切换时进程大概率会卡住，直到大场景加载完毕继续。另一种方式则是异步切换：即场景的切换是单独开一个线程去进行，而主线程则继续当前任务，直到场景线程将场景加载完毕后，生成的场景就可以加入到摄像机中了。

> 这里为了后续查询时方便，优先给出异步加载场景时可以会需要用到的几个关键词，方便后续查询：
>
> ```c#
> public AsyncOperation operation;
> IEnumerator loadSence()
>  {
>      SceneManager.LoadSceneAsync(1); //这里的1是场景编号
>      yield return operation;
>  }
> void Start()
>  {
>      StartCoroutine(loadSence());
>  }
> 
> void update()
> {
>     Debug.Log(operation.progress) //其中operation.progress可以用于场景加载时的进度条
> }
> ```

### 枚举

#### KeyCode

​	主要用于PC端的开发，用于映射键盘上的按键，对于26个字母也可以使用字母的小写直接代替其中的枚举对象。



