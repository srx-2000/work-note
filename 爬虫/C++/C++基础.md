# C、C++基础

## 基础概念

### 指针的理解

#### 2024.6.18

​	今天主要学了一下虚函数表和虚函数表指针，其间对指针做了几个小实验，有了一个比较好玩的理解：

```c++
#include <iostream>
using namespace std;
int number_a = 1000;
int* pnumber_a = &number_a;
cout << number_a << endl;
cout << pnumber_a << endl;
cout << *pnumber_a << endl;


/*
运行上面的代码应该可以得到下面的结果：
1000
0x0000EFAC1 之类的，反正是个地址
1000

那么根据这个结果就又回到了那个老生常谈的问题：指针就是地址，地址就是指针。上面代码中的&符号代表取地址符号，这个肯定是没有疑问的，所以&number_a那一定是一个地址对吧，而int* 这个东西本身其实就是一个类型声明，就与你用int声明了一个int一样。这个类型声明中的*并不是起取数的作用，而仅仅是一个声明标志符而已。再回到指针就是地址的问题上，即使是后续在c++中引入了引用对象之后，如果想要给一个指针变量赋值时，同样是使用&son【这里son代表一个引用实例】。也就是说还是去他的地址，赋值给这个指针。所以你可以这么理解指针：在第三个输出时使用的*，可以理解为一个取值的钥匙，你在声明指针变量的时候，使用了一个*作为钥匙打开了一个保险柜，并且把自己的要存放的东西存放在了这个保险柜里，而后保险柜给你吐出来一个保险柜锁在位置的编号牌【指针变量】。而后续你要取出你存的东西的话，就需要使用这个编号牌【指针变量】加上那个钥匙*，一起才可以把存在里面的东西拿出来。而这个编码牌当然也可以作为一个物件存储在另一个保险柜里，这也就是指针的指针的意思。
*/
```

### 内存中的数据结构

1. 在c++中主要存在两个大数据结构用于内存管理。一个是堆，一个是栈。在堆上声明出来的对象需要手动释放，而在栈中声明的对象则可以在其超过作用域后自动回收。

   > 1. 其中在堆中声明的对象，返回的都是一个指针。该指针指向了对象的起始地址。之所以返回的是指针，而非确定的实例对象，是因为在堆上，内存是动态分配的，程序在编译时并不知道对象的具体大小，生命周期【声明周期是由程序员手动delete来维护的】。
   >
   > 2. 而当一个对象是在栈上声明时，返回的则是一个实例对象，这是因为程序在编译时就会将对象内存地址、大小、生命周期这些问题全部确定，从而可以直接返回一个实例对象。

```C++
#include<iostream>
using namespace std;
class A{
    public:
    	int age;
    	A(int age):age(age){}
}
A* globalA;
void CreateA(){
    globalA = new A(15);
}

int main(){
    // 栈上声明，如果代码运行超过main函数的作用域后，stack_a会从栈中弹出，进而销毁。从而避免内存泄漏。
    A stack_a(13);
    // 堆上声明，当代码运行超过main作用域后，且在没有手动delete时，a_heap对象就会一直存在在内存中。
    // 换种说法，如果我在全局声明了一个globalA指针，且在CreateA这个方法创建一个对象，并将对象的地址指向globalA。此时globalA对象就是可以全局访问的。并不会在作用域外被自动回收掉。
    A* a_heap = new A(14);
    cout << a_heap->age << endl;
    cout << globalA->age << endl;
}
```

2. 在C++中结构体与类其实基本一致，都有构造函数、析构函数、成员变量、成员函数，同样都具有多态和继承关系等等。二者主要的区别在于默认访问控制，在类中默认访问控制是private，而在结构体中默认访问控制是public。 

## C、C++逆向常用基础函数

### std::string 的内存分布

[主要参考文章](https://blog.csdn.net/tjcwt2011/article/details/127729271)

**文章总结**：当字符串内容小于22个字节时，std::string 会直接将字符串放入栈帧中【也就是栈空间】。当字符串内容大于22字节时，会在堆上开辟一段空间用于存放字符串内容，而栈帧中则存放堆信息及堆地址。其中下方图片中全出的三个东西分别对应了：**开辟的堆空间大小**【可以理解为字符串buffer大小】，**字符串实际长度**，**字符串对应的堆空间地址**。

> 上面之所以是22字节，只是文章中作者使用的电脑分配的栈帧大小刚好为24字节【除去一个\0用于标识字符串的结束的字节，以及一个字符串长度的字节，刚好2字节】。实际上一个栈中可以容纳的字符串长度，还是得具体看被分配到的栈帧的大小-2字节。

​	之所以会研究这个问题，主要是在看课进行frida hook的时候遇见了一个莫名其妙的hexdump。乍一看感觉这就是一个没有实际内容的hexdump，但是课程讲师说这个就是比较经典的std::string内存分布。然后就直接断定下图中的`0x74cd685300`是我们需要的字符串的地址了。这就勾起了我的好奇心，随后便查到了上面那篇文章。文章讲的还是非常详细的。这里我只做一些我自己基础知识上的补充，以方便后续看上面那个文章不会晕。

![image-20240920143820459](C:\Users\beier\AppData\Roaming\Typora\typora-user-images\image-20240920143820459.png)

1. 在C++的栈内存分布上，栈遵循的是由低地址作为栈顶，高地址作为栈底的形式。这点可以看[逆向杂烩](./逆向杂烩.md)中的**栈指针的弹栈与压栈流程**部分。

2. 在c语言和C++中想要在栈中申请一段内存，其实不需要显式的关键词。只有在堆上申请内存才需要显式的关键词。

   > **C语言** 使用 `malloc()` 和 `free()` 来分配和释放堆上的内存
   >
   > **C++** 使用 `new` 和 `delete` 关键字来分配和释放堆上的内存。

3. 一字节等于两位十六进制数
4. C++内存模型参考文章：[C++内存分区模型 ](https://www.cnblogs.com/sarexpine/p/17576037.html)
