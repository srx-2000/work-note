# C++基础

## 基础概念

### 指针的理解

#### 2024.6.18

​	今天主要学了一下虚函数表和虚函数表指针，其间对指针做了几个小实验，有了一个比较好玩的理解：

```c++
#include <iostream>
using namespace std;
int number_a = 1000;
int* pnumber_a = &number_a;
cout << number_a << endl;
cout << pnumber_a << endl;
cout << *pnumber_a << endl;


/*
运行上面的代码应该可以得到下面的结果：
1000
0x0000EFAC1 之类的，反正是个地址
1000

那么根据这个结果就又回到了那个老生常谈的问题：指针就是地址，地址就是指针。上面代码中的&符号代表取地址符号，这个肯定是没有疑问的，所以&number_a那一定是一个地址对吧，而int* 这个东西本身其实就是一个类型声明，就与你用int声明了一个int一样。这个类型声明中的*并不是起取数的作用，而仅仅是一个声明标志符而已。再回到指针就是地址的问题上，即使是后续在c++中引入了引用对象之后，如果想要给一个指针变量赋值时，同样是使用&son【这里son代表一个引用实例】。也就是说还是去他的地址，赋值给这个指针。所以你可以这么理解指针：在第三个输出时使用的*，可以理解为一个取值的钥匙，你在声明指针变量的时候，使用了一个*作为钥匙打开了一个保险柜，并且把自己的要存放的东西存放在了这个保险柜里，而后保险柜给你吐出来一个保险柜锁在位置的编号牌【指针变量】。而后续你要取出你存的东西的话，就需要使用这个编号牌【指针变量】加上那个钥匙*，一起才可以把存在里面的东西拿出来。而这个编码牌当然也可以作为一个物件存储在另一个保险柜里，这也就是指针的指针的意思。
*/
```

### 内存中的数据结构

1. 在c++中主要存在两个大数据结构用于内存管理。一个是堆，一个是栈。在堆上声明出来的对象需要手动释放，而在栈中声明的对象则可以在其超过作用域后自动回收。

   > 1. 其中在堆中声明的对象，返回的都是一个指针。该指针指向了对象的起始地址。之所以返回的是指针，而非确定的实例对象，是因为在堆上，内存是动态分配的，程序在编译时并不知道对象的具体大小，声明周期【声明周期是由程序员手动delete来维护的】。
   >
   > 2. 而当一个对象是在栈上声明时，返回的则是一个实例对象，这是因为程序在编译时就会将对象内存地址、大小、生命周期这些问题全部确定，从而可以直接返回一个实例对象。

```C++
#include<iostream>
using namespace std;
class A{
    public:
    	int age;
    	A(int age):age(age){}
}
A* globalA;
void CreateA(){
    globalA = new A(15);
}

int main(){
    // 栈上声明，如果代码运行超过main函数的作用域后，stack_a会从栈中弹出，进而销毁。从而避免内存泄漏。
    A stack_a(13);
    // 堆上声明，当代码运行超过main作用域后，且在没有手动delete时，a_heap对象就会一直存在在内存中。
    // 换种说法，如果我在全局声明了一个globalA指针，且在CreateA这个方法创建一个对象，并将对象的地址指向globalA。此时globalA对象就是可以全局访问的。并不会在作用域外被自动回收掉。
    A* a_heap = new A(14);
    cout << a_heap->age << endl;
    cout << globalA->age << endl;
}
```

2. 在C++中结构体与类其实基本一致，都有构造函数、析构函数、成员变量、成员函数，同样都具有多态和继承关系等等。二者主要的区别在于默认访问控制，在类中默认访问控制是private，而在结构体中默认访问控制是public。 
