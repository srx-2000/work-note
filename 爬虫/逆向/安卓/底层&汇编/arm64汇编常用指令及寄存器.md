# arm64汇编常用指令及寄存器

## arm64汇编约定

1. 在进入一个函数的时候，`x0`到`x8`是寄存器分别存储了传入的8个参数
2. 在退出一个函数的时候，通常会以`x0`寄存器作为返回值的存储寄存器。但当返回的内容大于16字节时，会将返回值放到`x8`寄存器中存储。
3. lr寄存器是x30

## 指令

### 常用指令文档【英文版】

[文档](https://developer.arm.com/documentation/dui0473/m/arm-and-thumb-instructions/)

### LDR

​	ldr是Load Register的缩写，即加载到寄存器。主要功能是将一个地址或数据加载到寄存器中。

#### 基本语法

```assembly
LDR <DestinationRegister>, <Address>
```

#### 常见形式

##### 立即偏移地址

```assembly
LDR <Xt>, [<Xn|SP>, #<imm>] ; 加载64位数据
LDR <Wt>, [<Xn|SP>, #<imm>] ; 加载32位数据
```

- `<Xt>`: 目标64位寄存器
- `<Wt>`: 目标32位寄存器
- `<Xn|SP>`: 基址寄存器，或者栈指针寄存器
- `#<imm>`: 立即偏移量

##### 寄存器偏移地址

```assembly
LDR <Xt>, [<Xn|SP>, <Rm>, LSL #<shift>] ; 加载64位数据
LDR <Wt>, [<Xn|SP>, <Rm>, LSL #<shift>] ; 加载32位数据
```

- `<Rm>`: 用于偏移的寄存器
- `LSL #<shift>`: 可选的左移操作

#### trace示例

```assembly
"ldr x17, [x16, #0xc40]" x16=0x40070000 => x17=0xfffe1730
"ldr x17, [x16, #0xbd0]" x16=0x40070000 => x17=0x401dbb08
```

###### 示例说明【第一个】

> 1. 将寄存器x16中的数据加上立即数，获得一个地址：0x40070000+0xC40=0x40070C40
> 2. 获取1中计算出的地址，对应的数据：[0x40070C40]=0xfffe1730
> 3. 将2中获取的数据加载到x17中：x17=0xfffe1730

### BR

​	br是Branch Register的缩写，即分支跳转到寄存器。主要功能是将PC修改为传入的寄存器中的值，从而实现控制流的跳转。

#### 基本语法

```assembly
BR <Xn>
```

- `<Xt>`: 目标64位寄存器

#### trace示例

```assembly
"br x17" x17=0xfffe1730
"br x17" x17=0x401dbb08
```

###### 示例说明【第一个】

> 1. 跳转到寄存器x17中保存的地址：PC=0xfffe1730



### DCB、DCW、DCD、DCQ

​	上述四个指令本质上都是Define Constant，即常量声明，只不过不同的是最后声明的常量的大小，B代表Byte【一字节=8bit】、W代表Word【一字=2字节】、D代表Doubleword【两字】、Q代表QuadWord【四字】。其中Q和D还经常用在以下变量类型中：_QWORD、__DWORD

#### 基本语法【以DCB为例】

```assembly
DCB expr1 {, expr2} ...
```

- `expr1, expr2, ...`：表示一个或多个要定义的字节值，可以是立即数、字符常量或表达式。

#### 示例

```assembly
data_section
    DCB 0x01, 0x02, 0x03, 0x04       ; 定义四个字节，值分别为 0x01, 0x02, 0x03, 0x04
    DCB 'A', 'B', 'C', 'D'           ; 定义四个字节，值分别为 'A', 'B', 'C', 'D'
    DCB 255, 128, 64, 32             ; 定义四个字节，值分别为 255, 128, 64, 32
```

###### 示例说明

> 1. 第一行定义了四个字节，分别是 `0x01`, `0x02`, `0x03`, `0x04`。
> 2. 第二行定义了四个字节，分别是字符 `'A'`, `'B'`, `'C'`, `'D'`（它们的 ASCII 值）。
> 3. 第三行定义了四个字节，值分别是 `255`, `128`, `64`, `32`。

#### 使用场景

`DCB` 指令常用于：

- **初始化数据段**：为数据段定义和初始化字节。
- **定义字符串**：在内存中创建和初始化字符串。
- **配置数据**：定义和初始化配置数据或常量表。



### ALIGN

​	该指令不是缩写，本身就是对齐的意思。主要作用是将当前的地址对齐到指定的位数。对齐这件事本身是对代码的优化，可以提高访问效率，进而提高运行速度。

#### 基本语法

```assembly
ALIGN [boundary]
```

- `boundary`：可选参数，指定对齐的字节边界。如果省略，则默认对齐到 4 字节边界。常见的边界值有 2、4、8、16、32 等，其中16、32常写作`0x10`、`0x20`，具体取决于目标架构和数据类型。

#### 示例

```assembly
ORG 0x1005     ; 当前地址是 0x1005
BYTE 0xFF      ; 定义一个字节
ALIGN 4        ; 确保接下来的数据对齐到 4 字节边界
BYTE 0xAA      ; 定义一个字节
```

###### 示例说明

> 1. `ORG 0x1005`：当前地址设置为 `0x1005`。
>
> 2. `BYTE 0xFF`：定义一个字节，值为 `0xFF`，地址变为 `0x1006`。
>
> 3. `ALIGN 4`：当前地址 `0x1006` 不是 4 字节边界，需要插入 2 个填充字节，使地址变为 `0x1008`。
>
> 4. `BYTE 0xAA`：定义一个字节，值为 `0xAA`，地址变为 `0x1009`。

通过上面的例子可以看到其本身就是填充，即在他这条命令执行后，差了多少padding就padding多少，下面的代码再执行就是在他padding后的地址上继续执行的。

### BIC

​	BIC是Bit Clear的缩写。它通过对一个寄存器的值和另一个寄存器或立即数的按位取反后与操作，清除指定的位。也就是说，它将某些特定位清零，其它位保持不变。

#### 基本语法

```assembly
BIC <Rd>, <Rn>, <Rm>
BIC <Rd>, <Rn>, #<imm>
```

- `<Rd>`：目标寄存器，存储结果。
- `<Rn>`：第一个源寄存器，提供原始值。
- `<Rm>`：第二个源寄存器，其值会被按位取反，然后和 `<Rn>` 进行按位与操作。
- `#<imm>`：立即数，直接作为第二个操作数，它会先被按位取反，然后和 `<Rn>` 进行按位与操作。

#### 等价操作

```assembly
Rd = Rn & (~Rm)    // 或者 Rd = Rn & (~imm)
```

其中 `~` 表示按位取反操作，`&` 表示按位与操作。

#### trace示例

```assembly
x1=0000000000000075
x2=000000000000000E
"BIC W1, W2, W1" x1=000000000000000A  # 等价于： 000000000000000A = 000000000000000E & ~0000000000000075
```

###### 示例说明

> 1. 在进行BIC操作之前，x1和x2两个寄存器的值分别是0000000000000075和000000000000000E
> 2. 进行BIC操作的过程中，x2作为Rn，x1作为Rm，Rd

