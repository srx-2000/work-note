### 脱壳

​	首先是如何判断app加壳了，最直白的方式就是将apk文件拖拽到jadx中发现，明明一个很大的app，但是只解析出来几个简单类，并且在资源文件夹中找不到dex或找到的dex过少【只有一两个】，那么此时基本就可以判断是被加壳了。需要使用一些工具进行脱壳处理，这里暂时进介绍一些简单的脱壳方法，后续如果还有一些更复杂的再进行补充。

#### 使用firda_dump简单脱壳

首先是使用到的工具：frida、[脱壳工具](app_tool/dump_dex.js)。最终目的是通过脱壳工具找到应用真正存放dex的所在地，在找到并将dex成功拉到电脑上之后便可使用jadx直接解码。

##### 相关命令

```bash
# 使用adb命令获取正在运行的app的包全名
adb shell "dumpsys window | grep mCurrentFocus"
# 打开frida-server,/data/local/tmp为frida-server所在路径fd64为frida-server重命名后的可执行文件
adb shell
su
cd /data/local/tmp
./fd64
# 端口映射【另起一个命令行】，将手机的27042的端口映射到电脑端的27042上，其中27042为frida-server默认端口
adb forward tcp:27042 tcp:27042
# 使用frida和拓客工具获取真实dex所在地，在使用时需要要脱壳的工具是正在运行的。同时在运行之前需要打开frida.server同时需要做端口映射
frida -U (com.xxx.xxx) -l dump_dex.js(脱壳工具路径)

# 开启root
adb root
# 将手机端的dex拉到电脑上，如果在拉取时不成功，可以尝试在/sdcard目录下创建随意一个目录，先把dex拉到这个目录下再拉到电脑上
adb pull 手机端dex路径 电脑端路径
```

### 使用unidbg工具调用So文件

#### unidbg 

unidbg 是一个基于 unicorn 的逆向工具，可以黑盒调用安卓和 iOS 中的 so 文件。unidbg 是一个标准的 java 项目。
由于现在的大多数 app 把签名算法已经放到了 so 文件中，要想破解签名算法，必须能够破解 so 文件。C++ 的逆向远比 Java 的逆向要难得多了，所以好多时候是没法破解的，那么这个时候还可以采用 hook 的方法，直接读取程序中算出来的签名，但是这样的话，需要实际运行这个应用，需要模拟器或者真机，效率又不是很高（比如frida的rpc调用，就需要后台运行应用）。unidbg 就是一个很巧妙地解决方案，他不需要直接运行 app，也无需逆向 so 文件，而是通过在 app 中找到对应的 JNI 接口，然后用 unicorn 引擎直接执行这个 so 文件，所以效率也比较高。

#### 参考文章

unidbg 基础：https://www.52pojie.cn/thread-1322512-1-1.html

unidbg 使用实例：https://blog.csdn.net/chl191623691/article/details/118415796

#### 工具项目

​	unidbg是一个[github](https://github.com/zhkl0228/unidbg)上开源的maven项目，在使用时需要现有java，maven环境。然后将项目clone下来之后，使用标准的maven项目结构打开。而后在`src/test/java/com/xxxx/frameworks/core/encrypt`这个路径下找到`TTEncrypt`测试用例执行里面的main方法，如果没有问题，则会得到下图这样的输出样式

<img src="https://github.com/zhkl0228/unidbg/raw/master/assets/TTEncrypt.gif" alt="" style="max-width: 100%; display: inline-block;" data-target="animated-image.originalImage"></img>

#### 使用实例

使用时，打开unidbg项目，在其项目下编写脚本【主要之前尝试的maven导入并不是很好用，有些包导入不进来】。

```java
package cn.hestyle;
 
import com.github.unidbg.Module;
import com.github.unidbg.arm.ARMEmulator;
import com.github.unidbg.linux.android.AndroidARMEmulator;
import com.github.unidbg.linux.android.AndroidResolver;
import com.github.unidbg.linux.android.dvm.*;
import com.github.unidbg.memory.Memory;
 
 
import java.io.File;
import java.io.IOException;
 
/**
 * description: EncryptUtils调用so
 *
 * @author hestyle
 * @version 1.0
 * @className unidbg->EncryptUtilsJni
 * @date 2020-05-20 22:01
 **/
public class EncryptUtilsJni extends AbstractJni {
    // ARM模拟器
    private final ARMEmulator emulator;
    // vm
    private final VM vm;
    // 载入的模块
    private final Module module;
 
    private final DvmClass TTEncryptUtils;
 
    /**
     *
     * @param soFilePath   需要执行的so文件路径
     * @param classPath    需要执行的函数所在的Java类路径
     * @throws IOException
     */
    public EncryptUtilsJni(String soFilePath, String classPath) throws IOException {
        // 创建app进程，包名可任意写
        emulator = new AndroidARMEmulator("cn.hestyle");
        Memory memory = emulator.getMemory();
        // 作者支持19和23两个sdk
        memory.setLibraryResolver(new AndroidResolver(23));
        // 创建DalvikVM，利用apk本身，可以为null
        vm = ((AndroidARMEmulator) emulator).createDalvikVM(null);
        // （关键处1）加载so，填写so的文件路径
        DalvikModule dm = vm.loadLibrary(new File(soFilePath), false);
        // 调用jni
        dm.callJNI_OnLoad(emulator);
        module = dm.getModule();
        // （关键处2）加载so文件中的哪个类，填写完整的类路径
        TTEncryptUtils = vm.resolveClass(classPath);
    }
 
    /**
     * 调用so文件中的指定函数
     * @param methodSign 传入你要执行的函数信息，需要完整的smali语法格式的函数签名
     * @param args       是即将调用的函数需要的参数
     * @return 函数调用结果
     */
    private String myJni(String methodSign, Object ...args) {
        // 使用jni调用传入的函数签名对应的方法（）
        Number ret = TTEncryptUtils.callStaticJniMethod(emulator, methodSign, args);
        // ret存放返回调用结果存放的地址，获得函数执行后返回值
        StringObject str = vm.getObject(ret.intValue() & 0xffffffffL);
        return str.getValue();
    }
 
    /**
     * 关闭模拟器
     * @throws IOException
     */
    private void destroy() throws IOException {
        emulator.close();
        System.out.println("emulator destroy...");
    }
 
    public static void main(String[] args) throws IOException {
        // 1、需要调用的so文件所在路径
        String soFilePath = "src/test/resources/myso/libencryptLib.so";
        // 2、需要调用函数所在的Java类完整路径，比如a/b/c/d等等，注意需要用/代替.
        String classPath = "com/.../EncryptUtils";
        // 3、需要调用函数的函数签名，我这里调用EncryptUtils中的getGameKey方法，由于此方法没有参数列表，所以不需要传入
        String methodSign = "getGameKey()Ljava/lang/String;";
        EncryptUtilsJni encryptUtilsJni = new EncryptUtilsJni(soFilePath, classPath);
        // 输出getGameKey方法调用结果
        System.err.println(encryptUtilsJni.myJni(methodSign));
        encryptUtilsJni.destroy();
    }
}
```

