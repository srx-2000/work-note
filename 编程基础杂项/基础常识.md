# 基础常识

## 深拷贝与浅拷贝

二者主要针对引用对象的复制。

### 深拷贝

真的创建了一个新的对象，并且将要拷贝的对象的每一个属性都复制到这个新创建的对象中。

相对于浅拷贝由于开辟了新的地址，所以内存占用会比浅拷贝大。

### 浅拷贝

创建一个新的对象，然后将这个新的对象的引用指向老的那个对象的引用，从而达到复制的效果。所以浅拷贝可能会导致**数据污染**【自己瞎起的名字】。

#### 例子

```python
# 这里以python中我自己实际遇到过的一个情况说明数据污染。
data_a=dict()
data_a.update({"key_a_a":"value_a_a","key_a_b":"value_a_b"})
# 此处我的本意是声明一个新的b字典，并将字典a中的值放到b字典中，所以在我的预想中此时应该有两个独立地址，但值相同的字典a和b。
data_b=data_a
# 后续我又在b中添加了一些元素
data_b.update({"key_b_a":"value_b_a","key_b_b":"value_b_b"})
# 此时输出b当然是没有问题的，是四个元素。
print(data_b)
# 但是此时输出a就会有问题了，按照预想这里应该还是一个只有两个元素的，但实际上这里输出的值却与b中一致。
print(data_a)
# {'key_a_a': 'value_a_a', 'key_a_b': 'value_a_b', 'key_b_a': 'value_b_a', 'key_b_b': 'value_b_b'}
# {'key_a_a': 'value_a_a', 'key_a_b': 'value_a_b', 'key_b_a': 'value_b_a', 'key_b_b': 'value_b_b'}
 

#上述情况之所以会发生就是因为数据b只是将自己的引用指向了数据a。所以b中更改数据之后，有着相同引用的数据a也会随之改变，这就是浅拷贝。

# 那么如果想要做到预想中的“有两个独立地址，但值相同的字典a和b”，就应该使用深拷贝。
data_b = data_a.copy()
```

### 附录

​	在python中想要对自己声明的类使用深拷贝的话，直接自己写一个方法，里面创建一个新对象，并将传入进来的对象的属性重新赋值给新对象即可。

​	在java中可以方便一些：直接实现`Cloneable`或`Serializable`接口即可。

## 挂载

​	一直听说挂载的概念，但是从来没有深究过这东西到底是什么。所以总是在概念上模模糊糊的。现在趁着这次学习的机会用一些更易读懂的语言描述一下。

### 概念

​	挂载：指的就是将设备文件中的顶级目录连接到 Linux 根目录下的某一目录（最好是空目录），访问此目录就等同于访问设备文件

​	这里引用网络上的一句话：**既将一个文件系统的顶层目录挂到另一个文件系统的子目录上，使它们成为一个整体，称为挂载**

​	举个例子：将一个U盘插入电脑，U盘作为一种存储设备肯定是有自己的文件管理系统的，同时电脑也有自己的一套文件管理系统，那么此时想要在电脑这个文件管理系统中访问U盘这个文件系统该怎么办。有一个很符合直觉的方案就是将U盘的目录挂载到电脑的某一个目录下，这样我们想要访问U盘时只需要将U盘视作电脑目录中的一部分，与访问其他本来就在电脑上的目录一样操作。

![1702021305319](../../../Documents/WeChat Files/wxid_aet5r57pruhi22/FileStorage/Temp/1702021305319.jpg)

![1702021331153](../../../Documents/WeChat Files/wxid_aet5r57pruhi22/FileStorage/Temp/1702021331153.jpg)

在linux中，如果不挂载，通过Linux系统中的图形界面系统可以查看找到硬件设备，但命令行方式无法找到。

### 注意点

1. 挂载点必须是一个目录
2. 一个分区挂载在一个**已存在的目录**上，这个目录可以不为空，但**挂载后这个目录下以前的内容将不可用**；

### mount和umount指令的使用

#### mount

作用就是挂载，可以类比成Windows下的插入U盘，将一个分区挂载到一个目录下。

```bash
mount /dev/sda3(要挂载的分区) /mnt（挂载点）
# 参数
# -a 安装在/etc/fstab文件中列出的所有文件系统.
# -l 列出当前已挂载的设备,文件系统名称和挂载点
# -o 指定挂载选项,
# -t 文件系统类型,指定设备的文件系统类型，
# 	--ext2
# 	--Msdos
# 	--Vfat
# 	--Nfs
# 	--iso9660
# 	--Audo 自动检测文件系统
#   --tmpfs 挂载一个临时文件系统
```

##### 例子

```bash
mount -t tmpfs tmpfs /system/etc/security/cacerts
# 第二个tmpfs可以理解为上面公式中的/dev/sda3(要挂载的分区)
```

#### umount

作用是卸载，可以类比成Windows下的弹出U盘

```bash
umount /dev/sdb1(要被卸载的分区，并非挂载点)
```

